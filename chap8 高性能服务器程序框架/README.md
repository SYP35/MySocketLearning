# 第8章 高性能服务器框架

这一章是全书的核心，也是后续章节的总览。在这一章中，我们按照服务器程序的一般原理，
将服务器结构为如下三个主要模块：

- [ ] I/O处理单元。本章将介绍I/O处理单元的四种I/O模型和两种高效时间处理模式。

- [ ] 逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式----有限状态机。

- [ ] 存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。

最后，本章还介绍了提高服务器性能的其他建议。

-----------------------------------------------------------

## 8.1 服务器类型

### 8.1.1 C/S 模型

TCP服务器和TCP客户端的工作流程（图）

C/S模型非常适合资源相对几重的场合，并且它的实现也很简单，但其缺点也很明显：
服务器是通信的中心，当访问量过大时，可能所有客户端都将得到很慢的响应。


### 8.1.2 P2P模型

P2P模型使得每台机器在消耗服务的同事也给别人提供服务，这样自由能够充分、自由地共享。
P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络的负载将加重。

P2P模型还存在一个显著的问题，即主机之间很难互相发现。所以实际使用的P2P模型通常带有一个专门的发现服务器。
这个发现服务器通常还提供查找服务，使每个客户都能尽快地找到自己需要的资源。



-----------------------------------------------------------


## 8.2 服务器编程框架

- [ ] I/O 处理单元

- [ ] 请求队列

- [ ] 逻辑单元

- [ ] 请求队列

- [ ] 网络存储单元（可选）



I/O 处理单元是服务器管理客户连接的模块。

一个逻辑单元通常是一个进程或线程。

网络存储单元可以是数据库、缓存和文件。

请求队列是个单元之间的通信方式的抽象。



-----------------------------------------------------------

## 8.3 I/O 模型

- [ ] 阻塞 I/O 

- [ ] I/O 复用

- [ ] SIGIO 信号

- [ ] 异步 I/O


## 8.4两种高效的事件处理模式

服务器通常要处理3类事件：I/O事件、信号及定时事件。

### 8.4.1 Reactor 模式

Reactor是这样一种模式，它要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，
有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。
读写数据，接收新的连接，以及处理客户端请求均在工作线程中完成。


### 8.4.2 Proactor 模式

Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。



-----------------------------------------------------------

## 8.5 两种高效的并发模式

从实现上来说，并发编程主要有多进程和多线程两种方式。

并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的方法。

服务器主要有两种并发编程模式：
* 半同步/半异步（half-sync/half-async）模式
* 领导者/追随者（Leader/Followers）模式


### 8.5.1 半同步/半异步模式

在**I/O模型**中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），
以及该由谁来完成I/O读写（是应用程序还是内核）

在**并发模式**中，“同步”指的是程序完全按照代码序列的顺序指向；“异步”指的是程序的执行需要由系统事件来驱动。
常见的系统事件包括中断、信号等。

 半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理I/O事件。


### 8.5.2 领导者/追随者模式

领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。
在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件。
而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。
当前领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。
此时新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。

领导者/追随者模式包含如下几个组件：
* 句柄集（HandleSet）
* 线程集（ThreadSet）
* 事件处理器（EventHandler）
* 具体的事件处理器（ConcreateEventHandler）



-----------------------------------------------------------

## 8.6有限状态机

前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之间协调完成任务的各种模式，
这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机（finite  state  machine）

```C++
// code:8.1 

STATE_MACHINE( Package  _pack )
{
    PackageType  _type = _pack.GetType();

    switch( _type )
    {
        case type_A:
            process_package_A( _pack );
            break;
            
        case type_B:
            process_package_B( _pack );
            break;
    }
}
```


```C++
// code:8.2

STATE_MACHINE()
{
    State cur_State = type_A;
    while( cur_State != type_C )
    {
        Package  _pack = getNewPackage();
        
        switch( cur_State )
        {
            case type_A:
                process_package_state_A( _pack );
                cur_State = type_B;
                break;

            case type_B:
                process_package_state_B( _pack );
                cur_State = type_C;
                break;             
        }
    }
}
```


-----------------------------------------------------------

## 8.7提高服务器性能的其他建议

### 8.7.1池

根据不同的资源类型，池可分为很多种，常见的有内存池、进程池、线程池和连接池。
* **内存池**通常用于socket的接收缓存和发送缓存
* **进程池和线程池**都是并发编程常用的“伎俩”
* **连接池**通常用于服务器或服务器机群的内部永久连接

### 8.7.2数据复制

高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。


### 8.7.3上下文切换和锁

并发程序必须考虑上下文切换（context switch）的问题，即进程切换或线程切换导致的系统开销。

并发程序需要考虑的另外一个问题是共享资源的枷锁保护。锁通常被认为是导致服务器效率低下的一个因素，
因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。
如果必须使用“锁”，则可以考虑**减小锁的粒度**。


## 3个字符比较函数

* strpbrk()
* strcasecmp()
* strspn() 
* strcspn() 

```C++
#if _MSC_VER
#define strcasecmp _stricmp  //strcasecmp 找不到标识符
#endif


#include <iostream>
#include <string.h>
using namespace std;

int main()
{

///====================== strpbrk (比较的字符串，被比较的字符串)=======================
    //函数原型：extern char *strpbrk(char *str1, char *str2)
    //参数说明：str1待比较的字符串，str2为指定被搜索的字符串。
    //所在库名：#include <string.h>	//函数功能：比较字符串str1和str2中是否有相同的字符，
    //如果有，则返回该字符在str1中的位置的指针。
    //返回说明：返回指针，搜索到的字符在str1中的索引位置的指针。
    char str1[] = "hellostringEFG";
    char str2[] = "stringABC";
    char *str3 = new char[100];
    memset(str3, '\0', sizeof(str3));

    str3 = strpbrk(str1, str2);
    cout << str3 << endl;  //output: stringEFG


    //==================== strcasecmp() ====================
    // 头文件：#include <string.h>
    //定义函数：int strcasecmp(const char *s1, const char *s2);
    //函数说明：strcasecmp()用来比较参数s1 和s2 字符串，比较时会自动忽略大小写的差异。
    //返回值：若参数s1 和s2 字符串相同则返回0。s1 长度大于s2 长度则返回大于0 的值，
    //s1 长度若小于s2 长度则返回小于0 的值。
    char str4[] = "aBcDef";
    char str5[] = "ABCDEF";
    if (0 == strcasecmp(str4, str5))
    {
        cout << "equal" << endl;
    }
    else
    {
        cout << "NOT equal" << endl;
    }
    

    //======================== strspn() ===================
    //#include <string.h>
    //size_t strspn(const char *s, const char *accept);
    char *str6 = "1234567890";
    char *str7 = "1234567890";
    char *str8 = "65a3456";
    char *str9 = "12345678";
    
    printf("%s in %s is %d\n", str6, str7, strspn(str6, str7));
    printf("%s in %s is %d\n", str8, str9, strcspn(str8, str9));
    //1234567890 in 1234567890 is 10
    //65a3456 in 12345678 is 2


    //======================== strcspn() ==========================
    //#include <string.h>
    //size_t strcspn(const char *s, const char *reject);
    ///////////
    //函数说明：strcspn()从参数s 字符串的开头计算连续的字符，
    //而这些字符都完全不在参数reject 所指的字符串中。
    //简单地说， 若strcspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都不含字符串reject 内的字符。
    //返回值：返回字符串s 开头连续不含字符串reject 内的字符数目。
    char *str = "Linux was first developed for 386/486-based pcs. ";
    printf("%d\n", strcspn(str, " "));//5
    printf("%d\n", strcspn(str, "/-"));//33
    printf("%d\n", strcspn(str, "1234567890"));//30
    //5 //只计算到" "的出现, 所以返回"Linux"的长度
    //33 //计算到出现"/"或"－", 所以返回到"6"的长度
    //30 // 计算到出现数字字符为止, 所以返回"3"出现前的长度
//    char *str11 = "gdfa1234af5";
//    char *str10 = "ha";
    char *str11 = "1234567890";
    char *str10 = "89ab54";
    printf("%s in %s is %d\n", str10, str11, strcspn(str11, str10));

    system("pause");
    return 0;
}
```


-----------------------------------------------------

这里只是整理大概内容，更详细内容，**请看书**:book:[《Linux高性能服务器编程》](https://item.jd.com/27343565806.html) 游双  著，机械工业出版社]

